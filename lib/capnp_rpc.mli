module StructRef : sig
  type 'a t
  (** An ['a t] is a reference to a response message (that may not have arrived yet)
      with content type ['a]. *)
end

module rec Payload : sig
  type 'a t
  (** An ['a t] is a request or response payload: a struct and a cap table.
      To read the struct, use the one of the generated [_of_payload] method. *)

  type 'a index = private Uint32.t

  val import : 'a t -> 'b index -> 'b Capability.t
  (** [import t i] is the capability at index [i] in the table.
      Use the generated field accessors to get [i]. *)
end

and Capability : sig
  type 'a t
  (** An ['a t] is a capability reference to a service of type ['a]. *)

  type 'a capability_t = 'a t (* (alias because we have too many t's) *)

  type ('a, 'b) method_t
  (** A method on some instance, as seen by the client application code. *)

  module Request : sig
    type 'a t
    (** An ['a t] is a builder for the out-going request's payload. *)

    val create : (Capnp.Message.rw Capnp.BytesMessage.Slice.t -> 'a) -> 'a t * 'a
    (** [create init] is a fresh request payload and contents builder.
        Use one of the generated [init_pointer] functions for [init]. *)

    val create_no_args : unit -> 'a t
    (** [create_no_args ()] is a payload with no content. *)

    val export : 'a t -> 'b capability_t -> 'b Payload.index
    (** [export t cap] adds [cap] to the payload's CapDescriptor table and returns
        its index. You can use the index with the generated setter. *)
  end

  val call_full : ('a, 'b) method_t -> 'a Request.t -> 'b StructRef.t * 'b Payload.t Lwt.t
  (** [call_full m req] invokes [m req] and returns both a new StructRef.t (which
      can be used for pipelining) and an Lwt promise for the response message,
      when it arrives. *)

  val call_for_value : ('a, 'b) method_t -> 'a Request.t -> 'b Payload.t Lwt.t
  (** [call_for_value m req] invokes [m ret] and waits for the response.
      It is the same as [snd (call_full m req)].
      This is simpler than using [call_full], but doesn't support pipelining
      (you can't use any capabilities in the response in another message until the
      response arrives). *)

  val call_for_cap : ('a, 'b) method_t -> 'a Request.t -> 'c StructRef.t
  (** [call_for_cap m req] is [fst (call_full m req)]. It is useful when you just want to use
      the capabilities in the response but don't care about the message itself.
      This allows pipelining (the capabilities can be used before the response arrives). *)
end

module Service : sig
  type 'a response_promise
  (** The value returned by a local service method. Note that this may be the promise
      of a result from some other call. Use [return] for the common case of returning
      a payload directly. *)

  type ('a, 'b) method_t = 'a Payload.t -> 'b response_promise

  module Response : sig
    type 'b t
    (** An ['a t] is a builder for the out-going response's payload. *)

    val create : (Capnp.Message.rw Capnp.BytesMessage.Slice.t -> 'a) -> 'a t * 'a
    (** [create init] is a fresh request payload and contents builder.
        Use one of the generated [init_pointer] functions for [init]. *)

    val export : 'a t -> 'b Capability.t -> 'b Payload.index
    (** [export t cap] adds [cap] to the payload's CapDescriptor table and returns
        its index. You can use the index with the generated setter. *)
  end

  val return : 'a Response.t -> 'a response_promise
  (** [return r] wraps up a simple local result as a promise. *)

  val return_empty : unit -> 'a response_promise
  (** [return_empty ()] is a promise for a response with no payload. *)

  val return_lwt : 'a Response.t Lwt.t -> 'a response_promise
  (** [return_lwt l] is a local promise for the result of Lwt thread [l].
      Note that this does not support pipelining. *)

  val return_ref : 'a StructRef.t * 'a Payload.t Lwt.t -> 'a response_promise
  (** [return_ref r] repackages the result of a call made by the service as the response.
      This allows our client to pipeline messages directly to the call's target,
      without waiting for the response to arrive. *)
end

module Untyped : sig
  (** This module is only for use by the code generated by the capnp-ocaml
      schema compiler. The generated code provides type-safe wrappers for
      everything here. *)

  type pointer_r = Capnp.Message.ro Capnp.BytesMessage.Slice.t option

  val content_of_payload : 'a Payload.t -> pointer_r

  type abstract_method_t

  val abstract_method : ('a, 'b) Service.method_t -> abstract_method_t

  val bind_method : _ Capability.t -> interface_id:Uint64.t -> method_id:int ->
    ('a, 'b) Capability.method_t

  val struct_field : 'a StructRef.t -> int -> 'b StructRef.t

  val capability_field : 'a StructRef.t -> int -> 'b Capability.t

  val local :
    (interface_id:Uint64.t -> method_id:int -> abstract_method_t) ->
    'a Capability.t

  val cap_index : Uint32.t option -> _ Payload.index option
end

module Connection : sig
  type t
  (** A CapTP connection to a remote peer. *)

  val of_endpoint : ?offer:'a Capability.t -> ?tags:Logs.Tag.set -> switch:Lwt_switch.t -> Endpoint.t -> t
  (** [of_endpoint ?offer ~switch endpoint] is fresh CapTP connection wrapping [endpoint].
      If [offer] is given, the peer can use the "Bootstrap" message to get access to it.
      If the connection fails then [switch] will be turned off. *)

  val bootstrap : t -> 'a Capability.t
  (** [bootstrap t] is the peer's public bootstrap object, if any. *)

  val qid_tag : Uint32.t Logs.Tag.def
  (** [qid_tag] is used in log reports to tag the question (or answer) ID in the call.
      Useful for logging. *)
end

module Endpoint = Endpoint
module Ro_array = Ro_array
